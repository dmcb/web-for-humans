<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.0 butterfly.glb --transform --types
-->

<script lang="ts">
	import type * as THREE from 'three';
	import { Vector3, CatmullRomCurve3 } from 'three';
	import { T, useTask } from '@threlte/core';
	import { useGltf, useDraco, onReveal } from '@threlte/extras';

	interface Props {
		perchPoints: [number, number, number][];
		shookPerch: number;
	}

	let { perchPoints, shookPerch }: Props = $props();

	type GLTFResult = {
		nodes: {
			Cube: THREE.Mesh;
			Cube1: THREE.Mesh;
			Extrude: THREE.Mesh;
			Extrude_1: THREE.Mesh;
		};
		materials: {};
	};

	const dracoLoader = useDraco();
	const gltf = useGltf<GLTFResult>('/glb/butterfly.glb', { dracoLoader });

	let flightPath = new CatmullRomCurve3();
	let ref: THREE.Group | undefined;
	let flightTime = 0;
	let state = 'Perched';
	let targetPerch = -1;
	let perch = -1;
	let position = [0, 5, -0.2] as [number, number, number];

	function interpolatePoint(p1: Vector3, p2: Vector3, t: number, jitter: number): Vector3 {
		const x = p1.x + (p2.x - p1.x) * t + (Math.random() - 0.5) * jitter;
		const y = p1.y + (p2.y - p1.y) * t + (Math.random() - 0.5) * jitter;
		const z = 2; // Butterfly will fly in front of the words
		return new Vector3(x, y, z);
	}

	function setFlightPath(target: [number, number, number], jitter: number) {
		const originPoint = new Vector3(position[0], position[1], position[2]);
		const targetPoint = new Vector3(target[0], target[1], target[2]);
		const point1 = interpolatePoint(originPoint, targetPoint, 0.25, jitter);
		const point2 = interpolatePoint(originPoint, targetPoint, 0.5, jitter);
		const point3 = interpolatePoint(originPoint, targetPoint, 0.75, jitter);
		flightPath = new CatmullRomCurve3(
			[originPoint, point1, point2, point3, targetPoint],
			false,
			'chordal'
		);
	}

	function easeOutQuad(x: number): number {
		return 1 - (1 - x) * (1 - x);
	}

	function easeInOutSine(x: number): number {
		return -(Math.cos(Math.PI * x) - 1) / 2;
	}

	$effect(() => {
		if (shookPerch != -1) {
			if (state == 'Perched' && shookPerch == perch) {
				console.log('Butterfly leaving perch', perch);
				switchState('LeavingPerch');
			} else if (state == 'FlyingToPerch' && shookPerch == targetPerch) {
				console.log('Butterfly holding');
				switchState('HoldPattern');
			}
		}
	});

	onReveal(() => {
		setTimeout(() => {
			switchState('FlyingToPerch');
		}, 1000);
	});

	function switchState(newState: 'Perched' | 'LeavingPerch' | 'HoldPattern' | 'FlyingToPerch') {
		console.log('Switching state to', newState);
		state = newState;
		flightTime = 0;
		switch (state) {
			case 'Perched':
				perch = targetPerch;
				console.log('Perched on perch', perch);
				break;
			case 'LeavingPerch':
				// Fly in front of the words
				setFlightPath([position[0], position[1], 2], 0);
				break;
			case 'HoldPattern': {
				// Fly in a random tight pattern around the current location
				setFlightPath(position, 0.4);
				break;
			}
			case 'FlyingToPerch':
				// Fly in a lose pattern to a random perch, unless it's the shook perch
				do {
					targetPerch = Math.floor(Math.random() * perchPoints.length);
				} while (targetPerch == shookPerch);
				setFlightPath(perchPoints[targetPerch], 1);
				break;
		}
	}

	useTask((delta) => {
		if (ref) {
			position = [ref?.position.x, ref?.position.y, ref?.position.z];
		}
		flightTime += delta;
		switch (state) {
			case 'LeavingPerch':
				animateLeavingPerch();
				break;
			case 'HoldPattern':
				animateHoldPattern();
				break;
			case 'FlyingToPerch':
				animateFlyingToPerch();
				break;
		}
	});

	function animateLeavingPerch() {
		const duration = 0.4;
		const t = flightTime / duration;
		if (t > 1) {
			switchState('HoldPattern');
			return;
		}
		const x = easeOutQuad(t);
		const newPosition = flightPath.getPointAt(x);
		ref?.position.copy(newPosition);
	}

	function animateHoldPattern() {
		const duration = 4;
		const t = flightTime / duration;
		if (t > 1) {
			switchState('FlyingToPerch');
		} else {
			const newPosition = flightPath.getPointAt(t);
			ref?.position.copy(newPosition);
		}
	}

	function animateFlyingToPerch() {
		const duration = 3;
		const t = flightTime / duration;
		if (t > 1) {
			switchState('Perched');
		} else {
			const x = easeInOutSine(t);
			const newPosition = flightPath.getPointAt(x);
			ref?.position.copy(newPosition);
		}
	}
</script>

{#if $gltf}
	<T.Group bind:ref scale={0.01} rotation={[-Math.PI / 2, Math.PI / 4, Math.PI / 5]} {position}>
		<T.Mesh geometry={$gltf.nodes.Cube.geometry} rotation={[Math.PI / 2, 0, 0]}>
			<T.MeshStandardMaterial color={0xea594e} flatShading={true} />
		</T.Mesh>
		<T.Mesh geometry={$gltf.nodes.Cube1.geometry} rotation={[Math.PI / 2, 0, 0]}>
			<T.MeshStandardMaterial color={0xea594e} flatShading={true} />
		</T.Mesh>
		<T.Mesh geometry={$gltf.nodes.Extrude.geometry} rotation={[Math.PI / 2, 0, 0]}>
			<T.MeshStandardMaterial color={0xea594e} flatShading={true} />
		</T.Mesh>
		<T.Mesh geometry={$gltf.nodes.Extrude_1.geometry} rotation={[Math.PI / 2, 0, 0]}>
			<T.MeshStandardMaterial color={0xea594e} flatShading={true} />
		</T.Mesh>
	</T.Group>
{/if}

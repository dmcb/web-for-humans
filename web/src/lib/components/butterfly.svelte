<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.0 butterfly.glb --transform --types
-->

<script lang="ts">
	import type * as THREE from 'three';
	import { Vector3, CatmullRomCurve3 } from 'three';
	import { T, useTask } from '@threlte/core';
	import { useGltf, useDraco, onReveal } from '@threlte/extras';

	interface Props {
		position: [number, number, number];
		perchPoints: [number, number, number][];
	}

	let { position, perchPoints }: Props = $props();

	type GLTFResult = {
		nodes: {
			Cube: THREE.Mesh;
			Cube1: THREE.Mesh;
			Extrude: THREE.Mesh;
			Extrude_1: THREE.Mesh;
		};
		materials: {};
	};

	const dracoLoader = useDraco();
	const gltf = useGltf<GLTFResult>('/glb/butterfly.glb', { dracoLoader });

	function interpolatePoint(p1: Vector3, p2: Vector3, t: number, randomness: number): Vector3 {
		const x = p1.x + (p2.x - p1.x) * t + (Math.random() - 0.5) * randomness;
		const y = p1.y + (p2.y - p1.y) * t + (Math.random() - 0.5) * randomness;
		const z = p1.z + (p2.z - p1.z) * t + (Math.random() - 0.5) * randomness;
		return new Vector3(x, y, z);
	}

	function easeOutQuad(x: number): number {
		return 1 - (1 - x) * (1 - x);
	}

	let flightPath = new CatmullRomCurve3();
	let ref: THREE.Group | undefined;
	let flightTime = 0;

	let state = 'Perched';

	function switchState(newState: 'Perched' | 'LeavingPerch' | 'HoldPattern' | 'FlyingToPerch') {
		state = newState;
		flightTime = 0;
		switch (state) {
			case 'FlyingToPerch':
				setFlightPath(perchPoints[Math.floor(Math.random() * perchPoints.length)]);
				break;
		}
	}

	function setFlightPath(target: [number, number, number]) {
		const originPoint = new Vector3(position[0], position[1], position[2]);
		const targetPoint = new Vector3(target[0], target[1], target[2]);
		const point1 = interpolatePoint(originPoint, targetPoint, 0.25, 1.5);
		const point2 = interpolatePoint(originPoint, targetPoint, 0.5, 1.5);
		const point3 = interpolatePoint(originPoint, targetPoint, 0.75, 1.5);
		flightPath = new CatmullRomCurve3(
			[originPoint, point1, point2, point3, targetPoint],
			false,
			'chordal'
		);
	}

	onReveal(() => {
		switchState('FlyingToPerch');
	});

	useTask((delta) => {
		flightTime += delta;
		switch (state) {
			case 'Perched':
				// Do nothing
				break;
			case 'LeavingPerch':
				animateLeavingPerch();
				break;
			case 'HoldPattern':
				animateHoldPattern();
				break;
			case 'FlyingToPerch':
				animateFlyingToPerch();
				break;
		}
	});

	function animateLeavingPerch() {
		const duration = 1;
		const t = flightTime / duration;
		if (t > 1) {
			switchState('HoldPattern');
			return;
		}
		const x = easeOutQuad(t);
		const newPosition = flightPath.getPointAt(x);
		ref?.position.copy(newPosition);
	}

	function animateHoldPattern() {
		const duration = 5;
		const t = flightTime / duration;
		const newPosition = flightPath.getPointAt(t);
		ref?.position.copy(newPosition);
	}

	function animateFlyingToPerch() {
		const duration = 3;
		const t = flightTime / duration;
		if (t > 1) {
			switchState('Perched');
			return;
		}
		const x = easeOutQuad(t);
		const newPosition = flightPath.getPointAt(x);
		ref?.position.copy(newPosition);
	}

	// 4 animation states for the butterly, perched, flying in a hold pattern, flying to pearch, leaving pearch
	// 1. perched does nothing, until that word is hovered over, then butterfly switches to leave pearch
	// 2. leaving pearch flies away from the word with quick speed, easing out and then butterly switches to flying in a hold pattern
	// 3. flying in a hold pattern creates random tight flight paths and follows them at a constant speed until a certain time has elapsed, then butterfly switches to flying to pearch
	// 4. flying to pearch flies in a line with some random curves with a speed that eases out until it reaches the pearch point, then butterfly switches to perched
</script>

{#if $gltf}
	<T.Group bind:ref scale={0.01} rotation={[-Math.PI / 2, Math.PI / 4, Math.PI / 5]} {position}>
		<T.Mesh geometry={$gltf.nodes.Cube.geometry} rotation={[Math.PI / 2, 0, 0]}>
			<T.MeshStandardMaterial color={0xea594e} flatShading={true} />
		</T.Mesh>
		<T.Mesh geometry={$gltf.nodes.Cube1.geometry} rotation={[Math.PI / 2, 0, 0]}>
			<T.MeshStandardMaterial color={0xea594e} flatShading={true} />
		</T.Mesh>
		<T.Mesh geometry={$gltf.nodes.Extrude.geometry} rotation={[Math.PI / 2, 0, 0]}>
			<T.MeshStandardMaterial color={0xea594e} flatShading={true} />
		</T.Mesh>
		<T.Mesh geometry={$gltf.nodes.Extrude_1.geometry} rotation={[Math.PI / 2, 0, 0]}>
			<T.MeshStandardMaterial color={0xea594e} flatShading={true} />
		</T.Mesh>
	</T.Group>
{/if}
